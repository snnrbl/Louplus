/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
export var hasBuffer = (typeof Buffer !== 'undefined');
var textEncoder;
var textDecoder;
var VSBuffer = /** @class */ (function () {
    function VSBuffer(buffer) {
        this.buffer = buffer;
        this.byteLength = this.buffer.byteLength;
    }
    VSBuffer.alloc = function (byteLength) {
        if (hasBuffer) {
            return new VSBuffer(Buffer.allocUnsafe(byteLength));
        }
        else {
            return new VSBuffer(new Uint8Array(byteLength));
        }
    };
    VSBuffer.wrap = function (actual) {
        if (hasBuffer && !(Buffer.isBuffer(actual))) {
            // https://nodejs.org/dist/latest-v10.x/docs/api/buffer.html#buffer_class_method_buffer_from_arraybuffer_byteoffset_length
            // Create a zero-copy Buffer wrapper around the ArrayBuffer pointed to by the Uint8Array
            actual = Buffer.from(actual.buffer, actual.byteOffset, actual.byteLength);
        }
        return new VSBuffer(actual);
    };
    VSBuffer.fromString = function (source) {
        if (hasBuffer) {
            return new VSBuffer(Buffer.from(source));
        }
        else {
            if (!textEncoder) {
                textEncoder = new TextEncoder();
            }
            return new VSBuffer(textEncoder.encode(source));
        }
    };
    VSBuffer.concat = function (buffers, totalLength) {
        if (typeof totalLength === 'undefined') {
            totalLength = 0;
            for (var i = 0, len = buffers.length; i < len; i++) {
                totalLength += buffers[i].byteLength;
            }
        }
        var ret = VSBuffer.alloc(totalLength);
        var offset = 0;
        for (var i = 0, len = buffers.length; i < len; i++) {
            var element = buffers[i];
            ret.set(element, offset);
            offset += element.byteLength;
        }
        return ret;
    };
    VSBuffer.prototype.toString = function () {
        if (hasBuffer) {
            return this.buffer.toString();
        }
        else {
            if (!textDecoder) {
                textDecoder = new TextDecoder();
            }
            return textDecoder.decode(this.buffer);
        }
    };
    VSBuffer.prototype.slice = function (start, end) {
        // IMPORTANT: use subarray instead of slice because TypedArray#slice
        // creates shallow copy and NodeBuffer#slice doesn't. The use of subarray
        // ensures the same, performant, behaviour.
        return new VSBuffer(this.buffer.subarray(start /*bad lib.d.ts*/, end));
    };
    VSBuffer.prototype.set = function (array, offset) {
        this.buffer.set(array.buffer, offset);
    };
    VSBuffer.prototype.readUInt32BE = function (offset) {
        return readUInt32BE(this.buffer, offset);
    };
    VSBuffer.prototype.writeUInt32BE = function (value, offset) {
        writeUInt32BE(this.buffer, value, offset);
    };
    VSBuffer.prototype.readUInt8 = function (offset) {
        return readUInt8(this.buffer, offset);
    };
    VSBuffer.prototype.writeUInt8 = function (value, offset) {
        writeUInt8(this.buffer, value, offset);
    };
    return VSBuffer;
}());
export { VSBuffer };
export function readUInt32BE(source, offset) {
    return (source[offset] * Math.pow(2, 24)
        + source[offset + 1] * Math.pow(2, 16)
        + source[offset + 2] * Math.pow(2, 8)
        + source[offset + 3]);
}
export function writeUInt32BE(destination, value, offset) {
    destination[offset + 3] = value;
    value = value >>> 8;
    destination[offset + 2] = value;
    value = value >>> 8;
    destination[offset + 1] = value;
    value = value >>> 8;
    destination[offset] = value;
}
function readUInt8(source, offset) {
    return source[offset];
}
function writeUInt8(destination, value, offset) {
    destination[offset] = value;
}
export function isVSBufferReadableStream(obj) {
    var candidate = obj;
    return candidate && [candidate.on, candidate.pause, candidate.resume, candidate.destroy].every(function (fn) { return typeof fn === 'function'; });
}
/**
 * Helper to fully read a VSBuffer readable into a single buffer.
 */
export function readableToBuffer(readable) {
    var chunks = [];
    var chunk;
    while (chunk = readable.read()) {
        chunks.push(chunk);
    }
    return VSBuffer.concat(chunks);
}
/**
 * Helper to convert a buffer into a readable buffer.
 */
export function bufferToReadable(buffer) {
    var done = false;
    return {
        read: function () {
            if (done) {
                return null;
            }
            done = true;
            return buffer;
        }
    };
}
/**
 * Helper to fully read a VSBuffer stream into a single buffer.
 */
export function streamToBuffer(stream) {
    return new Promise(function (resolve, reject) {
        var chunks = [];
        stream.on('data', function (chunk) { return chunks.push(chunk); });
        stream.on('error', function (error) { return reject(error); });
        stream.on('end', function () { return resolve(VSBuffer.concat(chunks)); });
    });
}
/**
 * Helper to create a VSBufferStream from an existing VSBuffer.
 */
export function bufferToStream(buffer) {
    var stream = writeableBufferStream();
    stream.end(buffer);
    return stream;
}
/**
 * Helper to create a VSBufferStream from a Uint8Array stream.
 */
export function toVSBufferReadableStream(stream) {
    var vsbufferStream = writeableBufferStream();
    stream.on('data', function (data) { return vsbufferStream.write(typeof data === 'string' ? VSBuffer.fromString(data) : VSBuffer.wrap(data)); });
    stream.on('end', function () { return vsbufferStream.end(); });
    stream.on('error', function (error) { return vsbufferStream.error(error); });
    return vsbufferStream;
}
/**
 * Helper to create a VSBufferStream that can be pushed
 * buffers to. Will only start to emit data when a listener
 * is added.
 */
export function writeableBufferStream() {
    return new VSBufferWriteableStreamImpl();
}
var VSBufferWriteableStreamImpl = /** @class */ (function () {
    function VSBufferWriteableStreamImpl() {
        this.state = {
            flowing: false,
            ended: false,
            destroyed: false
        };
        this.buffer = {
            data: [],
            error: []
        };
        this.listeners = {
            data: [],
            error: [],
            end: []
        };
    }
    VSBufferWriteableStreamImpl.prototype.pause = function () {
        if (this.state.destroyed) {
            return;
        }
        this.state.flowing = false;
    };
    VSBufferWriteableStreamImpl.prototype.resume = function () {
        if (this.state.destroyed) {
            return;
        }
        if (!this.state.flowing) {
            this.state.flowing = true;
            // emit buffered events
            this.flowData();
            this.flowErrors();
            this.flowEnd();
        }
    };
    VSBufferWriteableStreamImpl.prototype.write = function (chunk) {
        if (this.state.destroyed) {
            return;
        }
        // flowing: directly send the data to listeners
        if (this.state.flowing) {
            this.listeners.data.forEach(function (listener) { return listener(chunk); });
        }
        // not yet flowing: buffer data until flowing
        else {
            this.buffer.data.push(chunk);
        }
    };
    VSBufferWriteableStreamImpl.prototype.error = function (error) {
        if (this.state.destroyed) {
            return;
        }
        // flowing: directly send the error to listeners
        if (this.state.flowing) {
            this.listeners.error.forEach(function (listener) { return listener(error); });
        }
        // not yet flowing: buffer errors until flowing
        else {
            this.buffer.error.push(error);
        }
    };
    VSBufferWriteableStreamImpl.prototype.end = function (result) {
        if (this.state.destroyed) {
            return;
        }
        // end with data or error if provided
        if (result instanceof Error) {
            this.error(result);
        }
        else if (result) {
            this.write(result);
        }
        // flowing: send end event to listeners
        if (this.state.flowing) {
            this.listeners.end.forEach(function (listener) { return listener(); });
            this.destroy();
        }
        // not yet flowing: remember state
        else {
            this.state.ended = true;
        }
    };
    VSBufferWriteableStreamImpl.prototype.on = function (event, callback) {
        if (this.state.destroyed) {
            return;
        }
        switch (event) {
            case 'data':
                this.listeners.data.push(callback);
                // switch into flowing mode as soon as the first 'data'
                // listener is added and we are not yet in flowing mode
                this.resume();
                break;
            case 'end':
                this.listeners.end.push(callback);
                // emit 'end' event directly if we are flowing
                // and the end has already been reached
                //
                // finish() when it went through
                if (this.state.flowing && this.flowEnd()) {
                    this.destroy();
                }
                break;
            case 'error':
                this.listeners.error.push(callback);
                // emit buffered 'error' events unless done already
                // now that we know that we have at least one listener
                if (this.state.flowing) {
                    this.flowErrors();
                }
                break;
        }
    };
    VSBufferWriteableStreamImpl.prototype.flowData = function () {
        if (this.buffer.data.length > 0) {
            var fullDataBuffer_1 = VSBuffer.concat(this.buffer.data);
            this.listeners.data.forEach(function (listener) { return listener(fullDataBuffer_1); });
            this.buffer.data.length = 0;
        }
    };
    VSBufferWriteableStreamImpl.prototype.flowErrors = function () {
        if (this.listeners.error.length > 0) {
            var _loop_1 = function (error) {
                this_1.listeners.error.forEach(function (listener) { return listener(error); });
            };
            var this_1 = this;
            for (var _i = 0, _a = this.buffer.error; _i < _a.length; _i++) {
                var error = _a[_i];
                _loop_1(error);
            }
            this.buffer.error.length = 0;
        }
    };
    VSBufferWriteableStreamImpl.prototype.flowEnd = function () {
        if (this.state.ended) {
            this.listeners.end.forEach(function (listener) { return listener(); });
            return this.listeners.end.length > 0;
        }
        return false;
    };
    VSBufferWriteableStreamImpl.prototype.destroy = function () {
        if (!this.state.destroyed) {
            this.state.destroyed = true;
            this.state.ended = true;
            this.buffer.data.length = 0;
            this.buffer.error.length = 0;
            this.listeners.data.length = 0;
            this.listeners.error.length = 0;
            this.listeners.end.length = 0;
        }
    };
    return VSBufferWriteableStreamImpl;
}());
