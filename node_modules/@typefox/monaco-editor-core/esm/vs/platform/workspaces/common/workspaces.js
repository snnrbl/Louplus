/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
import { createDecorator } from '../../instantiation/common/instantiation';
import { localize } from '../../../nls';
import { URI } from '../../../base/common/uri';
import { isWindows, isLinux, isMacintosh } from '../../../base/common/platform';
import { extname } from '../../../base/common/path';
import { dirname, resolvePath, isEqualAuthority, isEqualOrParent, relativePath, extname as resourceExtname } from '../../../base/common/resources';
import * as jsonEdit from '../../../base/common/jsonEdit';
import * as json from '../../../base/common/json';
import { Schemas } from '../../../base/common/network';
import { normalizeDriveLetter } from '../../../base/common/labels';
import { toSlashes } from '../../../base/common/extpath';
import { getRemoteAuthority } from '../../remote/common/remoteHosts';
export var IWorkspacesMainService = createDecorator('workspacesMainService');
export var IWorkspacesService = createDecorator('workspacesService');
export var WORKSPACE_EXTENSION = 'code-workspace';
export var WORKSPACE_FILTER = [{ name: localize('codeWorkspace', "Code Workspace"), extensions: [WORKSPACE_EXTENSION] }];
export var UNTITLED_WORKSPACE_NAME = 'workspace.json';
export function reviveWorkspaceIdentifier(workspace) {
    return { id: workspace.id, configPath: URI.revive(workspace.configPath) };
}
export function isStoredWorkspaceFolder(thing) {
    return isRawFileWorkspaceFolder(thing) || isRawUriWorkspaceFolder(thing);
}
export function isRawFileWorkspaceFolder(thing) {
    return thing
        && typeof thing === 'object'
        && typeof thing.path === 'string'
        && (!thing.name || typeof thing.name === 'string');
}
export function isRawUriWorkspaceFolder(thing) {
    return thing
        && typeof thing === 'object'
        && typeof thing.uri === 'string'
        && (!thing.name || typeof thing.name === 'string');
}
export function isSingleFolderWorkspaceIdentifier(obj) {
    return obj instanceof URI;
}
export function isWorkspaceIdentifier(obj) {
    var workspaceIdentifier = obj;
    return workspaceIdentifier && typeof workspaceIdentifier.id === 'string' && workspaceIdentifier.configPath instanceof URI;
}
export function toWorkspaceIdentifier(workspace) {
    if (workspace.configuration) {
        return {
            configPath: workspace.configuration,
            id: workspace.id
        };
    }
    if (workspace.folders.length === 1) {
        return workspace.folders[0].uri;
    }
    // Empty workspace
    return undefined;
}
export function isSingleFolderWorkspaceInitializationPayload(obj) {
    return isSingleFolderWorkspaceIdentifier(obj.folder);
}
var WORKSPACE_SUFFIX = '.' + WORKSPACE_EXTENSION;
export function hasWorkspaceFileExtension(path) {
    var ext = (typeof path === 'string') ? extname(path) : resourceExtname(path);
    return ext === WORKSPACE_SUFFIX;
}
var SLASH = '/';
/**
 * Given a folder URI and the workspace config folder, computes the IStoredWorkspaceFolder using
* a relative or absolute path or a uri.
 * Undefined is returned if the folderURI and the targetConfigFolderURI don't have the same schema or authority
 *
 * @param folderURI a workspace folder
 * @param folderName a workspace name
 * @param targetConfigFolderURI the folder where the workspace is living in
 * @param useSlashForPath if set, use forward slashes for file paths on windows
 */
export function getStoredWorkspaceFolder(folderURI, folderName, targetConfigFolderURI, useSlashForPath) {
    if (useSlashForPath === void 0) { useSlashForPath = !isWindows; }
    if (folderURI.scheme !== targetConfigFolderURI.scheme) {
        return { name: folderName, uri: folderURI.toString(true) };
    }
    var folderPath;
    if (isEqualOrParent(folderURI, targetConfigFolderURI)) {
        // use relative path
        folderPath = relativePath(targetConfigFolderURI, folderURI) || '.'; // always uses forward slashes
        if (isWindows && folderURI.scheme === Schemas.file && !useSlashForPath) {
            // Windows gets special treatment:
            // - use backslahes unless slash is used by other existing folders
            folderPath = folderPath.replace(/\//g, '\\');
        }
    }
    else {
        // use absolute path
        if (folderURI.scheme === Schemas.file) {
            folderPath = folderURI.fsPath;
            if (isWindows) {
                // Windows gets special treatment:
                // - normalize all paths to get nice casing of drive letters
                // - use backslahes unless slash is used by other existing folders
                folderPath = normalizeDriveLetter(folderPath);
                if (useSlashForPath) {
                    folderPath = toSlashes(folderPath);
                }
            }
        }
        else {
            if (!isEqualAuthority(folderURI.authority, targetConfigFolderURI.authority)) {
                return { name: folderName, uri: folderURI.toString(true) };
            }
            folderPath = folderURI.path;
        }
    }
    return { name: folderName, path: folderPath };
}
/**
 * Rewrites the content of a workspace file to be saved at a new location.
 * Throws an exception if file is not a valid workspace file
 */
export function rewriteWorkspaceFileForNewLocation(rawWorkspaceContents, configPathURI, targetConfigPathURI) {
    var storedWorkspace = doParseStoredWorkspace(configPathURI, rawWorkspaceContents);
    var sourceConfigFolder = dirname(configPathURI);
    var targetConfigFolder = dirname(targetConfigPathURI);
    var rewrittenFolders = [];
    var slashForPath = useSlashForPath(storedWorkspace.folders);
    // Rewrite absolute paths to relative paths if the target workspace folder
    // is a parent of the location of the workspace file itself. Otherwise keep
    // using absolute paths.
    for (var _i = 0, _a = storedWorkspace.folders; _i < _a.length; _i++) {
        var folder = _a[_i];
        var folderURI = isRawFileWorkspaceFolder(folder) ? resolvePath(sourceConfigFolder, folder.path) : URI.parse(folder.uri);
        rewrittenFolders.push(getStoredWorkspaceFolder(folderURI, folder.name, targetConfigFolder, slashForPath));
    }
    // Preserve as much of the existing workspace as possible by using jsonEdit
    // and only changing the folders portion.
    var formattingOptions = { insertSpaces: false, tabSize: 4, eol: (isLinux || isMacintosh) ? '\n' : '\r\n' };
    var edits = jsonEdit.setProperty(rawWorkspaceContents, ['folders'], rewrittenFolders, formattingOptions);
    var newContent = jsonEdit.applyEdits(rawWorkspaceContents, edits);
    if (storedWorkspace.remoteAuthority === getRemoteAuthority(targetConfigPathURI)) {
        // unsaved remote workspaces have the remoteAuthority set. Remove it when no longer nexessary.
        newContent = jsonEdit.applyEdits(newContent, jsonEdit.removeProperty(newContent, ['remoteAuthority'], formattingOptions));
    }
    return newContent;
}
function doParseStoredWorkspace(path, contents) {
    // Parse workspace file
    var storedWorkspace = json.parse(contents); // use fault tolerant parser
    // Filter out folders which do not have a path or uri set
    if (Array.isArray(storedWorkspace.folders)) {
        storedWorkspace.folders = storedWorkspace.folders.filter(function (folder) { return isStoredWorkspaceFolder(folder); });
    }
    // Validate
    if (!Array.isArray(storedWorkspace.folders)) {
        throw new Error(path + " looks like an invalid workspace file.");
    }
    return storedWorkspace;
}
export function useSlashForPath(storedFolders) {
    if (isWindows) {
        for (var _i = 0, storedFolders_1 = storedFolders; _i < storedFolders_1.length; _i++) {
            var folder = storedFolders_1[_i];
            if (isRawFileWorkspaceFolder(folder) && folder.path.indexOf(SLASH) >= 0) {
                return true;
            }
        }
        return false;
    }
    return true;
}
