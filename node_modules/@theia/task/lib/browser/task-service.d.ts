/********************************************************************************
 * Copyright (C) 2017 Ericsson and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
import { EditorManager } from '@theia/editor/lib/browser';
import { ILogger } from '@theia/core/lib/common';
import { ApplicationShell, FrontendApplication, WidgetManager } from '@theia/core/lib/browser';
import { QuickPickService } from '@theia/core/lib/common/quick-pick-service';
import { TaskResolverRegistry, TaskProviderRegistry } from './task-contribution';
import { TerminalService } from '@theia/terminal/lib/browser/base/terminal-service';
import { MessageService } from '@theia/core/lib/common/message-service';
import { OpenerService } from '@theia/core/lib/browser/opener-service';
import { ProblemManager } from '@theia/markers/lib/browser/problem/problem-manager';
import { WorkspaceService } from '@theia/workspace/lib/browser/workspace-service';
import { VariableResolverService } from '@theia/variable-resolver/lib/browser';
import { NamedProblemMatcher, TaskConfiguration, TaskInfo, TaskServer, RunTaskOption } from '../common';
import { TaskWatcher } from '../common/task-watcher';
import { TaskConfigurationClient, TaskConfigurations } from './task-configurations';
import { ProvidedTaskConfigurations } from './provided-task-configurations';
import { TaskDefinitionRegistry } from './task-definition-registry';
import { ProblemMatcherRegistry } from './task-problem-matcher-registry';
export interface QuickPickProblemMatcherItem {
    problemMatchers: NamedProblemMatcher[] | undefined;
    learnMore?: boolean;
}
export declare class TaskService implements TaskConfigurationClient {
    /**
     * Reflects whether a valid task configuration file was found
     * in the current workspace, and is being watched for changes.
     */
    protected configurationFileFound: boolean;
    /**
     * The last executed task.
     */
    protected lastTask: {
        source: string;
        taskLabel: string;
    } | undefined;
    protected cachedRecentTasks: TaskConfiguration[];
    protected readonly app: FrontendApplication;
    protected readonly shell: ApplicationShell;
    protected readonly taskServer: TaskServer;
    protected readonly logger: ILogger;
    protected readonly widgetManager: WidgetManager;
    protected readonly taskWatcher: TaskWatcher;
    protected readonly messageService: MessageService;
    protected readonly workspaceService: WorkspaceService;
    protected readonly taskConfigurations: TaskConfigurations;
    protected readonly providedTaskConfigurations: ProvidedTaskConfigurations;
    protected readonly variableResolverService: VariableResolverService;
    protected readonly taskResolverRegistry: TaskResolverRegistry;
    protected readonly terminalService: TerminalService;
    protected readonly editorManager: EditorManager;
    protected readonly problemManager: ProblemManager;
    protected readonly taskDefinitionRegistry: TaskDefinitionRegistry;
    protected readonly problemMatcherRegistry: ProblemMatcherRegistry;
    protected readonly quickPick: QuickPickService;
    protected readonly openerService: OpenerService;
    /**
     * @deprecated To be removed in 0.5.0
     */
    protected readonly taskProviderRegistry: TaskProviderRegistry;
    protected init(): void;
    /** Returns an array of the task configurations configured in tasks.json and provided by the extensions. */
    getTasks(): Promise<TaskConfiguration[]>;
    /** Returns an array of the task configurations which are configured in tasks.json files */
    getConfiguredTasks(): Promise<TaskConfiguration[]>;
    /** Returns an array of the task configurations which are provided by the extensions. */
    getProvidedTasks(): Promise<TaskConfiguration[]>;
    addRecentTasks(tasks: TaskConfiguration | TaskConfiguration[]): void;
    recentTasks: TaskConfiguration[];
    /**
     * Clears the list of recently used tasks.
     */
    clearRecentTasks(): void;
    /**
     * Returns a task configuration provided by an extension by task source and label.
     * If there are no task configuration, returns undefined.
     */
    getProvidedTask(source: string, label: string): Promise<TaskConfiguration | undefined>;
    /** Returns an array of running tasks 'TaskInfo' objects */
    getRunningTasks(): Promise<TaskInfo[]>;
    /** Returns an array of task types that are registered, including the default types */
    getRegisteredTaskTypes(): Promise<string[]>;
    /**
     * Get the last executed task.
     *
     * @returns the last executed task or `undefined`.
     */
    getLastTask(): {
        source: string;
        taskLabel: string;
    } | undefined;
    /**
     * Runs a task, by task configuration label.
     * Note, it looks for a task configured in tasks.json only.
     */
    runConfiguredTask(source: string, taskLabel: string): Promise<void>;
    /**
     * Run the last executed task.
     */
    runLastTask(): Promise<TaskInfo | undefined>;
    /**
     * Runs a task, by the source and label of the task configuration.
     * It looks for configured and detected tasks.
     */
    run(source: string, taskLabel: string): Promise<TaskInfo | undefined>;
    runTask(task: TaskConfiguration, option?: RunTaskOption): Promise<TaskInfo | undefined>;
    runTaskByLabel(taskLabel: string): Promise<boolean>;
    private removeProblemMarks;
    private getResolvedTask;
    /**
     * Runs the resolved task and opens terminal widget if the task is based on a terminal process
     * @param resolvedTask the resolved task
     * @param option options to run the resolved task
     */
    private runResolvedTask;
    private getCustomizeProblemMatcherItems;
    /**
     * Run selected text in the last active terminal.
     */
    runSelectedText(): Promise<void>;
    attach(processId: number, taskId: number): Promise<void>;
    configure(task: TaskConfiguration): Promise<void>;
    protected isEventForThisClient(context: string | undefined): boolean;
    taskConfigurationChanged(event: string[]): void;
    protected getContext(): string | undefined;
    /** Kill task for a given id if task is found */
    kill(id: number): Promise<void>;
}
//# sourceMappingURL=task-service.d.ts.map